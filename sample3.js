// Generated by WebPulse Request Flow Generator
// 2025-03-19T17:50:07.277Z

async function myCustomFlow(initialData = {}) {
  // Initialize data store and request queue
  const dataStore = { ...initialData };
  const requestQueue = [];
  const executedNodes = new Set();

  // Utility function to reference data from previous steps
  const getDataRef = (path) => {
    return extractDataByPath(dataStore, path);
  };

  // Register all nodes in the flow
  // Register undefined (r2)
  requestQueue.push({
    id: 'r2',
    name: 'undefined',
    type: 'REQUEST',
    properties: {
      "url": "https://youtube.com/",
      "headers": []
},
    execute: async function() {
      const url = "https://youtube.com/";
      const headers = [];

      const response = await fetch(
        url,
        {
          method: "GET",
          headers: headers,
        }
      );

      const processedResponse = await handleResponse(response);
      dataStore['r2'] = processedResponse;
      return processedResponse;
    }
  });
  // Register undefined (r1)
  requestQueue.push({
    id: 'r1',
    name: 'undefined',
    type: 'REQUEST',
    properties: {
      "url": "https://google.com/",
      "headers": []
},
    execute: async function() {
      const url = "https://google.com/";
      const headers = [];

      const response = await fetch(
        url,
        {
          method: "GET",
          headers: headers,
        }
      );

      const processedResponse = await handleResponse(response);
      dataStore['r1'] = processedResponse;
      return processedResponse;
    }
  });
  // Register undefined (cd1)
  requestQueue.push({
    id: 'cd1',
    name: 'undefined',
    type: 'CONDITION',
    properties: {
      "url": "https://youtube.com/",
      "headers": [],
      "condition": "dataStore.r1.body !== null"
},
    execute: async function() {
      try {
        // Create a safe evaluation function
        const evalFunc = new Function('dataStore', 'getDataRef', `return ${"dataStore.r1.body !== null"};`);
        const result = !!evalFunc(dataStore, getDataRef);
        console.log(`Condition evaluated to: ${result}`);
        dataStore['cd1_result'] = result;
        return result;
      } catch (error) {
        console.error('Error evaluating condition:', error);
        dataStore['cd1_error'] = error;
        return false;
      }
    }
  });

  // Execute the request flow
  async function executeFlow() {
    let nextNodeId = findStartNode();
    const maxSteps = 100; // Prevent infinite loops
    let steps = 0;

    while (nextNodeId && steps < maxSteps) {
      steps++;
      const currentNode = requestQueue.find(n => n.id === nextNodeId);
      if (!currentNode || executedNodes.has(nextNodeId)) break;

      try {
        console.log(`Executing node: ${currentNode.name} (${currentNode.type})`);
        await currentNode.execute();
        executedNodes.add(nextNodeId);
        // Determine next node based on the execution result
        nextNodeId = determineNextNode(nextNodeId);
      } catch (error) {
        console.error(`Error executing ${currentNode.name}:`, error);
        dataStore[`${nextNodeId}_error`] = error;
        if (errorHandling === 'continue') {
          nextNodeId = determineNextNode(nextNodeId);
        } else {
          break;
        }
      }
    }
  }

  // Find the starting node in the flow
  function findStartNode() {
    // Find nodes that aren't targets of any edges
    const targetNodeIds = new Set(["cd1"]);
    const potentialStartNodes = requestQueue.filter(node => !targetNodeIds.has(node.id));
    return potentialStartNodes.length > 0 ? potentialStartNodes[0].id : requestQueue[0]?.id;
  }

  // Determine the next node to execute based on the current node and its result
  function determineNextNode(currentNodeId) {
    const edges = [{"id":"edge_1742406565663","source":"r1","sourcePort":"response","target":"cd1","targetPort":"condition"}];
    const relevantEdges = edges.filter(edge => edge.source === currentNodeId);

    if (relevantEdges.length === 0) return null;

    // For condition nodes, use the result to determine which path to take
    const currentNode = requestQueue.find(n => n.id === currentNodeId);
    if (currentNode && currentNode.type === 'CONDITION') {
      const result = dataStore[`${currentNodeId}_result`];
      console.log(`Condition result: ${result}`);
      
      // Find the edge that matches the condition result
      const sourcePort = result ? 'true' : 'false';
      const matchingEdge = relevantEdges.find(e => e.sourcePort === sourcePort);
      
      if (matchingEdge) {
        console.log(`Taking ${sourcePort} path to node: ${matchingEdge.target}`);
        return matchingEdge.target;
      } else {
        console.log(`No matching edge found for condition result: ${sourcePort}`);
        return null;
      }
    }

    // For transform nodes, check if there are specific output paths
    if (currentNode && currentNode.type === 'TRANSFORM') {
      const transformResult = dataStore[`${currentNodeId}_output`];
      
      // Check if any edge has a sourcePort that matches a transform output path
      const outputEdge = relevantEdges.find(e => e.sourcePort && e.sourcePort === transformResult?.path);
      if (outputEdge) {
        console.log(`Taking transform output path: ${outputEdge.sourcePort} to node: ${outputEdge.target}`);
        return outputEdge.target;
      }
    }
    // For other nodes, take the first available edge
    return relevantEdges[0]?.target || null;
  }

  // Execute the flow
  await executeFlow();

  // Return the final data store
  return dataStore;
}

/**
 * Extract data from an object using a dot or bracket notation path
 * @param {Object} obj - The object to extract data from
 * @param {string} path - Path using dot or bracket notation (e.g., "user.profile.name" or "responses[0].body.id")
 * @returns {any} The extracted value or undefined if not found
 */
function extractDataByPath(obj, path) {
  if (!obj || !path) return undefined;

  // Handle special template syntax for data references
  if (path.startsWith('${') && path.endsWith('}')) {
    path = path.slice(2, -1).trim();
  }

  // Split the path by dots or bracket notation
  const keys = path.match(/\[([^\[\]]*?)\]|([^\[\]\.]+)/g) || [];
  let current = obj;

  for (let key of keys) {
    // Clean up the key by removing brackets and quotes
    key = key.replace(/^\[([^\]]+)\]$/, '$1')
           .replace(/^\["([^"]+)"\]$/, '$1')
           .replace(/^\['([^']+)'\]$/, '$1')
           .replace(/^\./g, '');

    if (current === null || current === undefined) {
      return undefined;
    }

    current = current[key];
  }

  return current;
}

/**
 * Process HTTP response and extract data
 * @param {Response} response - Fetch API Response object
 * @returns {Object} Processed response data
 */
async function handleResponse(response) {
  const contentType = response.headers.get('content-type') || '';
  let body;

  if (contentType.includes('application/json')) {
    body = await response.json();
  } else if (contentType.includes('text/')) {
    body = await response.text();
  } else {
    body = await response.arrayBuffer();
  }

  return {
    status: response.status,
    statusText: response.statusText,
    headers: Object.fromEntries(response.headers.entries()),
    body,
    raw: response
  };
}

// Example usage:
// myCustomFlow().then(result => console.log(result));

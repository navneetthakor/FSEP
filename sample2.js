// Generated by WebPulse Request Flow Generator
// 2025-03-18T10:02:31.528Z

async function myCustomFlow(initialData = {}) {
  // Initialize data store and request queue
  const dataStore = { ...initialData };
  const requestQueue = [];
  const executedNodes = new Set();

  // Utility function to reference data from previous steps
  const getDataRef = (path) => {
    return extractDataByPath(dataStore, path);
  };

  // Register all nodes in the flow
  // Register undefined (navneet)
  requestQueue.push({
    id: 'navneet',
    name: 'undefined',
    type: 'REQUEST',
    properties: {
      "url": "https://youtube.com",
      "headers": []
},
    execute: async function() {
      const url = "https://youtube.com";
      const headers = [];

      const response = await fetch(
        url,
        {
          method: "GET",
          headers: headers,
        }
      );

      const processedResponse = await handleResponse(response);
      dataStore['navneet'] = processedResponse;
      return processedResponse;
    }
  });
  // Register undefined (myCondition)
  requestQueue.push({
    id: 'myCondition',
    name: 'undefined',
    type: 'CONDITION',
    properties: {
      "url": "https://youtube.com/",
      "headers": [],
      "method": "DELETE",
      "condition": "${navneet.body} !== undefined"
},
    execute: async function() {
      try {
        // Create a safe evaluation function
        const evalFunc = new Function('dataStore', 'getDataRef', `return ${"${navneet.body} !== undefined"};`);
        const result = !!evalFunc(dataStore, getDataRef);
        console.log(`Condition evaluated to: ${result}`);
        dataStore['myCondition_result'] = result;
        return result;
      } catch (error) {
        console.error('Error evaluating condition:', error);
        dataStore['myCondition_error'] = error;
        return false;
      }
    }
  });
  // Register undefined (hina)
  requestQueue.push({
    id: 'hina',
    name: 'undefined',
    type: 'REQUEST',
    properties: {
      "url": "https://api.github.com/user/navneetthakor",
      "headers": []
},
    execute: async function() {
      const url = "https://api.github.com/user/navneetthakor";
      const headers = [];

      const response = await fetch(
        url,
        {
          method: "GET",
          headers: headers,
        }
      );

      const processedResponse = await handleResponse(response);
      dataStore['hina'] = processedResponse;
      return processedResponse;
    }
  });
  // Register undefined (meet)
  requestQueue.push({
    id: 'meet',
    name: 'undefined',
    type: 'REQUEST',
    properties: {
      "url": "https://youtube.com",
      "headers": []
},
    execute: async function() {
      const url = "https://youtube.com";
      const headers = [];

      const response = await fetch(
        url,
        {
          method: "GET",
          headers: headers,
        }
      );

      const processedResponse = await handleResponse(response);
      dataStore['meet'] = processedResponse;
      return processedResponse;
    }
  });

  // Execute the request flow
  async function executeFlow() {
    let nextNodeId = findStartNode();
    const maxSteps = 100; // Prevent infinite loops
    let steps = 0;

    while (nextNodeId && steps < maxSteps) {
      steps++;
      const currentNode = requestQueue.find(n => n.id === nextNodeId);
      if (!currentNode || executedNodes.has(nextNodeId)) break;

      try {
        console.log(`Executing node: ${currentNode.name}`);
        await currentNode.execute();
        executedNodes.add(nextNodeId);
        // Determine next node based on the execution result
        nextNodeId = determineNextNode(nextNodeId);
      } catch (error) {
        console.error(`Error executing ${currentNode.name}:`, error);
        dataStore[`${nextNodeId}_error`] = error;
        if (errorHandling === 'continue') {
          nextNodeId = determineNextNode(nextNodeId);
        } else {
          break;
        }
      }
    }
  }

  // Find the starting node in the flow
  function findStartNode() {
    // Find nodes that aren't targets of any edges
    const targetNodeIds = new Set(["meet","myCondition","hina"]);
    const potentialStartNodes = requestQueue.filter(node => !targetNodeIds.has(node.id));
    return potentialStartNodes.length > 0 ? potentialStartNodes[0].id : requestQueue[0]?.id;
  }

  // Determine the next node to execute based on the current node and its result
  function determineNextNode(currentNodeId) {
    const edges = [{"id":"edge_1742290732710","source":"navneet","sourcePort":"response","target":"meet","targetPort":"method"},{"id":"edge_1742292093200","source":"navneet","sourcePort":"response","target":"myCondition","targetPort":"condition"},{"id":"edge_1742292147302","source":"myCondition","sourcePort":"true","target":"hina","targetPort":"url"}];
    const relevantEdges = edges.filter(edge => edge.source === currentNodeId);

    if (relevantEdges.length === 0) return null;

    // For condition nodes, use the result to determine which path to take
    const currentNode = requestQueue.find(n => n.id === currentNodeId);
    if (currentNode && currentNode.type === 'CONDITION') {
      const result = dataStore[`${currentNodeId}_result`] ? 'true' : 'false';
      const edge = relevantEdges.find(e => e.sourcePort === result);
      return edge ? edge.target : null;
    }

    // For other nodes, take the first available edge
    return relevantEdges[0]?.target || null;
  }

  // Execute the flow
  await executeFlow();

  // Return the final data store
  return dataStore;
}

/**
 * Extract data from an object using a dot or bracket notation path
 * @param {Object} obj - The object to extract data from
 * @param {string} path - Path using dot or bracket notation (e.g., "user.profile.name" or "responses[0].body.id")
 * @returns {any} The extracted value or undefined if not found
 */
function extractDataByPath(obj, path) {
  if (!obj || !path) return undefined;

  // Handle special template syntax for data references
  if (path.startsWith('${') && path.endsWith('}')) {
    path = path.slice(2, -1).trim();
  }

  // Split the path by dots or bracket notation
  const keys = path.match(/\[([^\[\]]*?)\]|([^\[\]\.]+)/g) || [];
  let current = obj;

  for (let key of keys) {
    // Clean up the key by removing brackets and quotes
    key = key.replace(/^\[([^\]]+)\]$/, '$1')
           .replace(/^\["([^"]+)"\]$/, '$1')
           .replace(/^\['([^']+)'\]$/, '$1')
           .replace(/^\./g, '');

    if (current === null || current === undefined) {
      return undefined;
    }

    current = current[key];
  }

  return current;
}

/**
 * Process HTTP response and extract data
 * @param {Response} response - Fetch API Response object
 * @returns {Object} Processed response data
 */
async function handleResponse(response) {
  const contentType = response.headers.get('content-type') || '';
  let body;

  if (contentType.includes('application/json')) {
    body = await response.json();
  } else if (contentType.includes('text/')) {
    body = await response.text();
  } else {
    body = await response.arrayBuffer();
  }

  return {
    status: response.status,
    statusText: response.statusText,
    headers: Object.fromEntries(response.headers.entries()),
    body,
    raw: response
  };
}

// Example usage:
myCustomFlow().then(result => console.log(result));

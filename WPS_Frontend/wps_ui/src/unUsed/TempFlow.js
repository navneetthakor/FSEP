// WebPulseFlowGenerator.js - Enhanced version with data referencing capabilities
export class WebPulseFlowGenerator {
    constructor() {
      this.nodes = [];
      this.edges = [];
    }
  
    /**
     * Import flow configuration from the canvas
     * @param {Object} flowConfig - The flow configuration object
     */
    importFlow(flowConfig) {
      this.nodes = flowConfig.nodes || [];
      this.edges = flowConfig.edges || [];
      return this;
    }
  
    /**
     * Generate executable code for the flow
     * @param {Object} options - Code generation options
     * @returns {string} Generated code
     */
    generateCode(options = {}) {
      const {
        includeComments = true,
        includeExampleUsage = true,
        functionName = 'executeRequestFlow',
        errorHandling = 'basic',
      } = options;
      
      // Sort nodes to ensure dependencies are processed in correct order
      const sortedNodes = this._sortNodes();
      
      let code = '';
      
      // Add header
      if (includeComments) {
        code += `// Generated by WebPulse Request Flow Generator\n`;
        code += `// ${new Date().toISOString()}\n\n`;
      }
      
      // Start function definition
      code += `async function ${functionName}(initialData = {}) {\n`;
      code += `  // Initialize data store\n`;
      code += `  const dataStore = { ...initialData };\n`;
      code += `  let currentStep = null;\n\n`;

      // Add data reference utility function
      code += `  // Utility function to reference data from previous steps\n`;
      code += `  const getDataRef = (path) => {\n`;
      code += `    return extractDataByPath(dataStore, path);\n`;
      code += `  };\n\n`;
      
      // Generate node execution code
      sortedNodes.forEach(node => {
        if (includeComments) {
          code += `  // ${node.name} (${node.id})\n`;
        }
        
        code += this._generateNodeCode(node, errorHandling);
      });
      
      // Add flow control logic if there are edges
      if (this.edges.length > 0) {
        if (includeComments) {
          code += `  // Define the flow logic\n`;
        }
        
        code += this._generateFlowLogic();
      }
      
      // Return data store
      code += `  // Return the final data store\n`;
      code += `  return dataStore;\n`;
      code += `}\n\n`;

      // Add data extraction utility function
      code += `/**\n`;
      code += ` * Extract data from an object using a dot or bracket notation path\n`;
      code += ` * @param {Object} obj - The object to extract data from\n`;
      code += ` * @param {string} path - Path using dot or bracket notation (e.g., "user.profile.name" or "responses[0].body.id")\n`;
      code += ` * @returns {any} The extracted value or undefined if not found\n`;
      code += ` */\n`;
      code += `function extractDataByPath(obj, path) {\n`;
      code += `  if (!obj || !path) return undefined;\n\n`;
      code += `  // Handle special template syntax for data references\n`;
      code += `  if (path.startsWith('${') && path.endsWith('}')) {\n`;
      code += `    path = path.slice(2, -1).trim();\n`;
      code += `  }\n\n`;
      code += `  // Split the path by dots or bracket notation\n`;
      code += `  const keys = path.match(/\\[([^\\[\\]]*?)\\]|([^\\[\\]\\.]+)/g) || [];\n`;
      code += `  let current = obj;\n\n`;
      code += `  for (let key of keys) {\n`;
      code += `    // Remove brackets if present\n`;
      code += `    key = key.replace(/^\\[([^\\]]+)\\]$/, '$1').replace(/^\\["([^"]+)"\\]$/, '$1').replace(/^\\['([^']+)'\\]$/, '$1');\n`;
      code += `    // Remove leading dots if present\n`;
      code += `    key = key.replace(/^\\./g, '');\n\n`;
      code += `    if (current === null || current === undefined) {\n`;
      code += `      return undefined;\n`;
      code += `    }\n\n`;
      code += `    current = current[key];\n`;
      code += `  }\n\n`;
      code += `  return current;\n`;
      code += `}\n\n`;
      
      // Add example usage
      if (includeExampleUsage) {
        code += `// Example usage:\n`;
        code += `// ${functionName}().then(result => console.log(result));\n`;
      }
      
      return code;
    }
  
    /**
     * Generate a self-contained module that can be imported
     * @param {Object} options - Module generation options
     * @returns {string} Generated module code
     */
    generateModule(options = {}) {
      const {
        moduleType = 'esm', // 'esm' or 'commonjs'
        includeUtils = true,
      } = options;
      
      let code = '';
      
      // Add imports based on module type
      if (moduleType === 'esm') {
        code += `// WebPulse Flow - Generated Module\n\n`;
        if (includeUtils) {
          code += `import { handleResponse, evaluateCondition, extractDataByPath } from './webpulse-utils.js';\n\n`;
        }
      } else {
        code += `// WebPulse Flow - Generated Module\n\n`;
        if (includeUtils) {
          code += `const { handleResponse, evaluateCondition, extractDataByPath } = require('./webpulse-utils');\n\n`;
        }
      }
      
      // Add utility functions if needed and not imported
      if (!includeUtils) {
        code += this._generateUtilityFunctions();
      }
      
      // Add the main execution function
      code += this.generateCode({
        includeComments: true,
        includeExampleUsage: false,
        functionName: 'executeFlow',
        errorHandling: 'advanced',
      });
      
      // Export the function based on module type
      if (moduleType === 'esm') {
        code += `export default executeFlow;\n`;
      } else {
        code += `module.exports = executeFlow;\n`;
      }
      
      return code;
    }
  
    /**
     * Generate utility functions for the flow
     * @returns {string} Utility functions code
     */
    _generateUtilityFunctions() {
      let code = `// Utility functions\n\n`;
      
      // Response handler
      code += `/**\n`;
      code += ` * Process HTTP response and extract data\n`;
      code += ` * @param {Response} response - Fetch API Response object\n`;
      code += ` * @returns {Object} Processed response data\n`;
      code += ` */\n`;
      code += `async function handleResponse(response) {\n`;
      code += `  const contentType = response.headers.get('content-type') || '';\n`;
      code += `  let body;\n\n`;
      code += `  if (contentType.includes('application/json')) {\n`;
      code += `    body = await response.json();\n`;
      code += `  } else if (contentType.includes('text/')) {\n`;
      code += `    body = await response.text();\n`;
      code += `  } else {\n`;
      code += `    body = await response.arrayBuffer();\n`;
      code += `  }\n\n`;
      code += `  return {\n`;
      code += `    status: response.status,\n`;
      code += `    statusText: response.statusText,\n`;
      code += `    headers: Object.fromEntries(response.headers.entries()),\n`;
      code += `    body,\n`;
      code += `    raw: response\n`;
      code += `  };\n`;
      code += `}\n\n`;
      
      // Condition evaluator
      code += `/**\n`;
      code += ` * Safely evaluate a condition with access to data store\n`;
      code += ` * @param {string} condition - Condition expression to evaluate\n`;
      code += ` * @param {Object} dataStore - Current data store\n`;
      code += ` * @returns {boolean} Result of condition evaluation\n`;
      code += ` */\n`;
      code += `function evaluateCondition(condition, dataStore) {\n`;
      code += `  try {\n`;
      code += `    // Create a safe evaluation function\n`;
      code += `    const evalFunc = new Function('dataStore', 'getDataRef', \`return \${condition};\`);\n`;
      code += `    // Create data reference function\n`;
      code += `    const getDataRef = (path) => extractDataByPath(dataStore, path);\n`;
      code += `    return !!evalFunc(dataStore, getDataRef);\n`;
      code += `  } catch (error) {\n`;
      code += `    console.error('Error evaluating condition:', error);\n`;
      code += `    return false;\n`;
      code += `  }\n`;
      code += `}\n\n`;

      // Data extraction utility
      code += `/**\n`;
      code += ` * Extract data from an object using a dot or bracket notation path\n`;
      code += ` * @param {Object} obj - The object to extract data from\n`;
      code += ` * @param {string} path - Path using dot or bracket notation (e.g., "user.profile.name" or "responses[0].body.id")\n`;
      code += ` * @returns {any} The extracted value or undefined if not found\n`;
      code += ` */\n`;
      code += `function extractDataByPath(obj, path) {\n`;
      code += `  if (!obj || !path) return undefined;\n\n`;
      code += `  // Handle special template syntax for data references\n`;
      code += `  if (path.startsWith('${') && path.endsWith('}')) {\n`;
      code += `    path = path.slice(2, -1).trim();\n`;
      code += `  }\n\n`;
      code += `  // Split the path by dots or bracket notation\n`;
      code += `  const keys = path.match(/\\[([^\\[\\]]*?)\\]|([^\\[\\]\\.]+)/g) || [];\n`;
      code += `  let current = obj;\n\n`;
      code += `  for (let key of keys) {\n`;
      code += `    // Remove brackets if present\n`;
      code += `    key = key.replace(/^\\[([^\\]]+)\\]$/, '$1').replace(/^\\["([^"]+)"\\]$/, '$1').replace(/^\\['([^']+)'\\]$/, '$1');\n`;
      code += `    // Remove leading dots if present\n`;
      code += `    key = key.replace(/^\\./g, '');\n\n`;
      code += `    if (current === null || current === undefined) {\n`;
      code += `      return undefined;\n`;
      code += `    }\n\n`;
      code += `    current = current[key];\n`;
      code += `  }\n\n`;
      code += `  return current;\n`;
      code += `}\n\n`;
      
      return code;
    }
  
    /**
     * Generate code for a specific node
     * @param {Object} node - The node object
     * @param {string} errorHandling - Error handling strategy ('basic' or 'advanced')
     * @returns {string} Generated node code
     */
    _generateNodeCode(node, errorHandling) {
      let code = `  currentStep = '${node.id}';\n`;
      
      if (errorHandling === 'advanced') {
        code += `  try {\n`;
      }
      
      const safeNodeId = node.id.replace('-', '_');
      
      switch (node.type) {
        case 'REQUEST':
          code += this._generateRequestNodeCode(node, safeNodeId);
          break;
          
        case 'CONDITION':
          code += this._generateConditionNodeCode(node, safeNodeId);
          break;
          
        case 'TRANSFORM':
          code += this._generateTransformNodeCode(node, safeNodeId);
          break;
          
        default:
          code += `    // Unknown node type: ${node.type}\n`;
      }
      
      if (errorHandling === 'advanced') {
        code += `  } catch (error) {\n`;
        code += `    dataStore.${node.id}_error = error;\n`;
        code += `    console.error('Error in ${node.name}:', error);\n`;
        code += `  }\n\n`;
      } else {
        code += `\n`;
      }
      
      return code;
    }
  
    /**
     * Generate code for a request node
     * @param {Object} node - The request node
     * @param {string} safeNodeId - Safe version of node ID for variable names
     * @returns {string} Generated code
     */
    _generateRequestNodeCode(node, safeNodeId) {
      let code = `    console.log('Executing HTTP request: ${node.name}');\n`;
      
      // Handle dynamic URL with support for data references
      const url = node.properties.url || 'https://example.com';
      const hasTemplateVars = url.includes('${');
      let urlCode;
      
      if (hasTemplateVars) {
        // Process template variables for data references
        urlCode = this._processTemplate(url);
      } else {
        urlCode = JSON.stringify(url);
      }
      
      // Handle headers with potential for dynamic content and data references
      const headers = node.properties.headers || {};
      let headersCode;
      
      if (typeof headers === 'string') {
        if (headers.includes('${')) {
          // Dynamic headers as string template with data references
          headersCode = this._processTemplate(headers);
        } else {
          headersCode = headers;
        }
      } else if (Object.values(headers).some(val => typeof val === 'string' && val.includes('${'))) {
        // Object with some dynamic values
        headersCode = '{\n';
        Object.entries(headers).forEach(([key, value]) => {
          if (typeof value === 'string' && value.includes('${')) {
            // Process template for data references
            headersCode += `        "${key}": ${this._processTemplate(value)},\n`;
          } else {
            headersCode += `        "${key}": ${JSON.stringify(value)},\n`;
          }
        });
        headersCode += '      }';
      } else {
        // Static headers
        headersCode = JSON.stringify(headers, null, 6);
      }
      
      // Handle request body with data references
      const method = node.properties.method || 'GET';
      let bodyCode = 'undefined';
      
      if (method !== 'GET' && method !== 'HEAD') {
        const body = node.properties.body || {};
        
        if (typeof body === 'string') {
          if (body.includes('${')) {
            // Template string body with data references
            bodyCode = this._processTemplate(body);
          } else {
            // Regular string body
            try {
              // Check if it's a JSON string
              JSON.parse(body);
              bodyCode = body;
            } catch (e) {
                console.log(e);
              // Not JSON, use as is
              bodyCode = JSON.stringify(body);
            }
          }
        } else if (typeof body === 'object') {
          // Check if any values contain data references
          const containsDataRefs = this._objectContainsDataRefs(body);
          
          if (containsDataRefs) {
            // Generate code to process data references in object
            bodyCode = this._generateDynamicObjectCode(body);
          } else {
            // Static object
            bodyCode = JSON.stringify(body);
          }
        }
      }
      
      code += `    const response_${safeNodeId} = await fetch(\n`;
      code += `      ${urlCode},\n`;
      code += `      {\n`;
      code += `        method: ${JSON.stringify(method)},\n`;
      code += `        headers: ${headersCode},\n`;
      
      if (method !== 'GET' && method !== 'HEAD') {
        if (bodyCode !== 'undefined') {
          const contentType = (headers && headers['Content-Type']) || (headers && headers['content-type']);
          
          if (contentType && contentType.includes('application/json')) {
            code += `        body: JSON.stringify(${bodyCode}),\n`;
          } else {
            code += `        body: ${bodyCode},\n`;
          }
        }
      }
      
      code += `      }\n`;
      code += `    );\n\n`;
      
      // Process response
      code += `    const processedResponse = await handleResponse(response_${safeNodeId});\n`;
      code += `    dataStore.${node.id} = processedResponse;\n`;
      
      return code;
    }
  
    /**
     * Process template strings with data references
     * @param {string} template - Template string with potential data references
     * @returns {string} Processed template with proper data reference code
     */
    _processTemplate(template) {
      // Replace ${...} data references with proper function calls
      const processedTemplate = template.replace(/\${([^}]+)}/g, (match, path) => {
        // If the path appears to be a direct dataStore reference, keep it
        if (path.startsWith('dataStore.')) {
          return '${' + path + '}';
        }
        // Otherwise, wrap it with getDataRef function
        return '${getDataRef("' + path.replace(/"/g, '\\"') + '")}';
      });
      
      return '`' + processedTemplate + '`';
    }
    
    /**
     * Check if an object contains data references in any of its values
     * @param {Object} obj - The object to check
     * @returns {boolean} True if the object contains data references
     */
    _objectContainsDataRefs(obj) {
      if (!obj || typeof obj !== 'object') return false;
      
      return Object.values(obj).some(value => {
        if (typeof value === 'string') {
          return value.includes('${');
        } else if (typeof value === 'object' && value !== null) {
          return this._objectContainsDataRefs(value);
        }
        return false;
      });
    }
    
    /**
     * Generate code for dynamic object with data references
     * @param {Object} obj - The object with potential data references
     * @returns {string} Generated code for the dynamic object
     */
    _generateDynamicObjectCode(obj) {
      if (!obj) return 'undefined';
      
      // Use JSON.stringify with a replacer function to handle data references
      let json = JSON.stringify(obj, null, 2);
      
      // Replace string data references with proper function calls
      json = json.replace(/"(\${[^}]+})"/g, (match, template) => {
        return template.replace(/\${([^}]+)}/g, (m, path) => {
          if (path.startsWith('dataStore.')) {
            return '${' + path + '}';
          }
          return '${getDataRef("' + path.replace(/"/g, '\\"') + '")}';
        });
      });
      
      // Convert to template literal if needed
      if (json.includes('${')) {
        return '`' + json.replace(/`/g, '\\`') + '`';
      }
      
      return json;
    }
  
    /**
     * Generate code for a condition node
     * @param {Object} node - The condition node
     * @param {string} safeNodeId - Safe version of node ID for variable names
     * @returns {string} Generated code
     */
    _generateConditionNodeCode(node, safeNodeId) {
      let code = `    console.log('Evaluating condition: ${node.name}');\n`;
      
      const condition = node.properties.condition || 'false';
      
      // Enhance condition to support data references
      const enhancedCondition = condition.replace(/dataStore\["([^"]+)"\]\.body\.([a-zA-Z0-9_]+)/g, 
        'getDataRef("$1.body.$2")');
      
      code += `    const condition_${safeNodeId} = evaluateCondition(\n`;
      code += `      ${JSON.stringify(enhancedCondition)},\n`;
      code += `      dataStore\n`;
      code += `    );\n`;
      code += `    dataStore.${node.id}_result = condition_${safeNodeId};\n`;
      
      return code;
    }
  
    /**
     * Generate code for a transform node
     * @param {Object} node - The transform node
     * @param {string} safeNodeId - Safe version of node ID for variable names
     * @returns {string} Generated code
     */
    _generateTransformNodeCode(node, safeNodeId) {
      let code = `    console.log('Executing transform: ${node.name}');\n`;
      
      const transform = node.properties.transform || '// No transform specified\nreturn dataStore;';
      
      // Enhance transform function with access to data reference utility
      code += `    const transform_${safeNodeId} = ((dataStore, getDataRef) => {\n`;
      code += `      try {\n`;
      
      // Split transform code into lines and add proper indentation
      const transformLines = transform.split('\n');
      transformLines.forEach(line => {
        code += `        ${line}\n`;
      });
      
      code += `      } catch (e) {\n`;
      code += `        console.error('Error in transform:', e);\n`;
      code += `        return null;\n`;
      code += `      }\n`;
      code += `    })(dataStore, getDataRef);\n`;
      code += `    dataStore.${node.id}_output = transform_${safeNodeId};\n`;
      
      return code;
    }
  
    /**
     * Generate flow control logic based on edges
     * @returns {string} Generated flow logic code
     */
    _generateFlowLogic() {
      let code = `  const flowLogic = {\n`;
      
      // Group edges by source node
      const edgesBySource = {};
      
      this.edges.forEach(edge => {
        if (!edgesBySource[edge.source]) {
          edgesBySource[edge.source] = {};
        }
        edgesBySource[edge.source][edge.sourcePort] = edge.target;
      });
      
      // Add grouped edges to the flow logic
      Object.entries(edgesBySource).forEach(([sourceId, ports]) => {
        code += `    '${sourceId}': {\n`;
        
        Object.entries(ports).forEach(([port, targetId]) => {
          code += `      '${port}': '${targetId}',\n`;
        });
        
        code += `    },\n`;
      });
      
      code += `  };\n\n`;
      
      // Add flow execution logic
      code += `  // Execute flow based on conditions\n`;
      code += `  let nextNode = Object.keys(flowLogic)[0]; // Start with first node\n`;
      code += `  const maxSteps = 100; // Prevent infinite loops\n`;
      code += `  let steps = 0;\n\n`;
      
      code += `  while (nextNode && steps < maxSteps) {\n`;
      code += `    steps++;\n`;
      code += `    const node = flowLogic[nextNode];\n`;
      code += `    if (!node) break;\n\n`;
      
      code += `    // Determine next step based on condition results\n`;
      code += `    if (dataStore[nextNode + '_result'] !== undefined) {\n`;
      code += `      // Handle condition nodes\n`;
      code += `      const result = dataStore[nextNode + '_result'] ? 'true' : 'false';\n`;
      code += `      nextNode = node[result];\n`;
      code += `    } else {\n`;
      code += `      // Handle other node types\n`;
      code += `      nextNode = node['response'] || node['output'] || null;\n`;
      code += `    }\n`;
      code += `  }\n\n`;
      
      return code;
    }
  
    /**
     * Sort nodes based on dependencies defined in edges
     * @returns {Array} Sorted nodes
     */
    _sortNodes() {
      const visited = new Set();
      const result = [];
      const nodeMap = {};
      
      // Create a map of nodes for quick access
      this.nodes.forEach(node => {
        nodeMap[node.id] = node;
      });
      
      // Create a graph of dependencies
      const graph = {};
      this.nodes.forEach(node => {
        graph[node.id] = [];
      });
      
      this.edges.forEach(edge => {
        if (graph[edge.source]) {
          graph[edge.source].push(edge.target);
        }
      });
      
      // Topological sort function
      const visit = (nodeId) => {
        if (visited.has(nodeId)) return;
        visited.add(nodeId);
        
        if (graph[nodeId]) {
          graph[nodeId].forEach(childId => {
            visit(childId);
          });
        }
        
        if (nodeMap[nodeId]) {
          result.unshift(nodeMap[nodeId]);
        }
      };
      
      // Visit all nodes
      this.nodes.forEach(node => {
        visit(node.id);
      });
      
      return result;
    }
  
    /**
     * Generate utility module file
     * @param {string} type - Module type ('esm' or 'commonjs')
     * @returns {string} Utility module code
     */
    generateUtilsModule(type = 'esm') {
      let code = `// WebPulse Flow Utilities\n\n`;
      
      // Add utility function implementations
      code += this._generateUtilityFunctions();
      
      // Export based on module type
      if (type === 'esm') {
        code += `export { handleResponse, evaluateCondition, extractDataByPath };\n`;
      } else {
        code += `module.exports = { handleResponse, evaluateCondition, extractDataByPath };\n`;
      }
      
      return code;
    }
  }
  
  // Example usage with data references
  // 
  const generator = new WebPulseFlowGenerator();
  generator.importFlow({
    nodes: [
      {
        id: 'auth-request',
        type: 'REQUEST',
        name: 'Authentication Request',
        position: { x: 100, y: 100 },
        properties: {
          url: 'https://api.example.com/auth',
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: {
            username: 'testuser',
            password: 'password123'
          }
        }
      },
      {
        id: 'get-user',
        type: 'REQUEST',
        name: 'Get User Data',
        position: { x: 300, y: 100 },
        properties: {
          url: 'https://api.example.com/users/profile',
          method: 'GET',
          headers: {
            'Authorization': 'Bearer ${auth-request.body.token}'
          }
        }
      },
      {
        id: 'check-status',
        type: 'CONDITION',
        name: 'Check Status',
        position: { x: 500, y: 100 },
        properties: {
          condition: 'getDataRef("get-user.status") === 200'
        }
      }
    ],
    edges: [
      {
        id: 'edge-1',
        source: 'auth-request',
        sourcePort: 'response',
        target: 'get-user',
        targetPort: 'request'
      },
      {
        id: 'edge-2',
        source: 'get-user',
        sourcePort: 'response',
        target: 'check-status',
        targetPort: 'condition'
      }
    ]
  });
  
  const code = generator.generateCode();
  console.log(code);
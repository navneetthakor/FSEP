// WebPulseFlowGenerator.js - CodeGen library for Request Flow
export class WebPulseFlowGenerator {
    constructor() {
      this.nodes = [];
      this.edges = [];
    }
  
    /**
     * Import flow configuration from the canvas
     * @param {Object} flowConfig - The flow configuration object
     */
    importFlow(flowConfig) {
      this.nodes = flowConfig.nodes || [];
      this.edges = flowConfig.edges || [];
      return this;
    }
  
    /**
     * Generate executable code for the flow
     * @param {Object} options - Code generation options
     * @returns {string} Generated code
     */
    generateCode(options = {}) {
      const {
        includeComments = true,
        includeExampleUsage = true,
        functionName = 'executeRequestFlow',
        errorHandling = 'basic',
      } = options;
      
      // Sort nodes to ensure dependencies are processed in correct order
      const sortedNodes = this._sortNodes();
      
      let code = '';
      
      // Add header
      if (includeComments) {
        code += `// Generated by WebPulse Request Flow Generator\n`;
        code += `// ${new Date().toISOString()}\n\n`;
      }
      
      // Start function definition
      code += `async function ${functionName}(initialData = {}) {\n`;
      code += `  // Initialize data store\n`;
      code += `  const dataStore = { ...initialData };\n`;
      code += `  let currentStep = null;\n\n`;
      
      // Generate node execution code
      sortedNodes.forEach(node => {
        if (includeComments) {
          code += `  // ${node.name} (${node.id})\n`;
        }
        
        code += this._generateNodeCode(node, errorHandling);
      });
      
      // Add flow control logic if there are edges
      if (this.edges.length > 0) {
        if (includeComments) {
          code += `  // Define the flow logic\n`;
        }
        
        code += this._generateFlowLogic();
      }
      
      // Return data store
      code += `  // Return the final data store\n`;
      code += `  return dataStore;\n`;
      code += `}\n\n`;
      
      // Add example usage
      if (includeExampleUsage) {
        code += `// Example usage:\n`;
        code += `// ${functionName}().then(result => console.log(result));\n`;
      }
      
      return code;
    }
  
    /**
     * Generate a self-contained module that can be imported
     * @param {Object} options - Module generation options
     * @returns {string} Generated module code
     */
    generateModule(options = {}) {
      const {
        moduleType = 'esm', // 'esm' or 'commonjs'
        includeUtils = true,
      } = options;
      
      let code = '';
      
      // Add imports based on module type
      if (moduleType === 'esm') {
        code += `// WebPulse Flow - Generated Module\n\n`;
        if (includeUtils) {
          code += `import { handleResponse, evaluateCondition } from './webpulse-utils.js';\n\n`;
        }
      } else {
        code += `// WebPulse Flow - Generated Module\n\n`;
        if (includeUtils) {
          code += `const { handleResponse, evaluateCondition } = require('./webpulse-utils');\n\n`;
        }
      }
      
      // Add utility functions if needed and not imported
      if (!includeUtils) {
        code += this._generateUtilityFunctions();
      }
      
      // Add the main execution function
      code += this.generateCode({
        includeComments: true,
        includeExampleUsage: false,
        functionName: 'executeFlow',
        errorHandling: 'advanced',
      });
      
      // Export the function based on module type
      if (moduleType === 'esm') {
        code += `export default executeFlow;\n`;
      } else {
        code += `module.exports = executeFlow;\n`;
      }
      
      return code;
    }
  
    /**
     * Generate utility functions for the flow
     * @returns {string} Utility functions code
     */
    _generateUtilityFunctions() {
      let code = `// Utility functions\n\n`;
      
      // Response handler
      code += `/**\n`;
      code += ` * Process HTTP response and extract data\n`;
      code += ` * @param {Response} response - Fetch API Response object\n`;
      code += ` * @returns {Object} Processed response data\n`;
      code += ` */\n`;
      code += `async function handleResponse(response) {\n`;
      code += `  const contentType = response.headers.get('content-type') || '';\n`;
      code += `  let body;\n\n`;
      code += `  if (contentType.includes('application/json')) {\n`;
      code += `    body = await response.json();\n`;
      code += `  } else if (contentType.includes('text/')) {\n`;
      code += `    body = await response.text();\n`;
      code += `  } else {\n`;
      code += `    body = await response.arrayBuffer();\n`;
      code += `  }\n\n`;
      code += `  return {\n`;
      code += `    status: response.status,\n`;
      code += `    statusText: response.statusText,\n`;
      code += `    headers: Object.fromEntries(response.headers.entries()),\n`;
      code += `    body,\n`;
      code += `    raw: response\n`;
      code += `  };\n`;
      code += `}\n\n`;
      
      // Condition evaluator
      code += `/**\n`;
      code += ` * Safely evaluate a condition with access to data store\n`;
      code += ` * @param {string} condition - Condition expression to evaluate\n`;
      code += ` * @param {Object} dataStore - Current data store\n`;
      code += ` * @returns {boolean} Result of condition evaluation\n`;
      code += ` */\n`;
      code += `function evaluateCondition(condition, dataStore) {\n`;
      code += `  try {\n`;
      code += `    // Create a safe evaluation function\n`;
      code += `    const evalFunc = new Function('dataStore', \`return \${condition};\`);\n`;
      code += `    return !!evalFunc(dataStore);\n`;
      code += `  } catch (error) {\n`;
      code += `    console.error('Error evaluating condition:', error);\n`;
      code += `    return false;\n`;
      code += `  }\n`;
      code += `}\n\n`;
      
      return code;
    }
  
    /**
     * Generate code for a specific node
     * @param {Object} node - The node object
     * @param {string} errorHandling - Error handling strategy ('basic' or 'advanced')
     * @returns {string} Generated node code
     */
    _generateNodeCode(node, errorHandling) {
      let code = `  currentStep = '${node.id}';\n`;
      
      if (errorHandling === 'advanced') {
        code += `  try {\n`;
      }
      
      const safeNodeId = node.id.replace('-', '_');
      
      switch (node.type) {
        case 'REQUEST':
          code += this._generateRequestNodeCode(node, safeNodeId);
          break;
          
        case 'CONDITION':
          code += this._generateConditionNodeCode(node, safeNodeId);
          break;
          
        case 'TRANSFORM':
          code += this._generateTransformNodeCode(node, safeNodeId);
          break;
          
        default:
          code += `    // Unknown node type: ${node.type}\n`;
      }
      
      if (errorHandling === 'advanced') {
        code += `  } catch (error) {\n`;
        code += `    dataStore.${node.id}_error = error;\n`;
        code += `    console.error('Error in ${node.name}:', error);\n`;
        code += `  }\n\n`;
      } else {
        code += `\n`;
      }
      
      return code;
    }
  
    /**
     * Generate code for a request node
     * @param {Object} node - The request node
     * @param {string} safeNodeId - Safe version of node ID for variable names
     * @returns {string} Generated code
     */
    _generateRequestNodeCode(node, safeNodeId) {
      let code = `    console.log('Executing HTTP request: ${node.name}');\n`;
      
      // Handle dynamic URL (support for template literals)
      const url = node.properties.url || 'https://example.com';
      const hasTemplateVars = url.includes('${');
      const urlCode = hasTemplateVars ? '`' + url + '`' : JSON.stringify(url);
      
      // Handle headers with potential for dynamic content
      const headers = node.properties.headers || {};
      let headersCode;
      
      if (typeof headers === 'string' && headers.includes('${')) {
        // Dynamic headers as string template
        headersCode = '`' + headers + '`';
      } else if (Object.values(headers).some(val => typeof val === 'string' && val.includes('${'))) {
        // Object with some dynamic values
        headersCode = '{\n';
        Object.entries(headers).forEach(([key, value]) => {
          if (typeof value === 'string' && value.includes('${')) {
            headersCode += `        "${key}": \`${value}\`,\n`;
          } else {
            headersCode += `        "${key}": ${JSON.stringify(value)},\n`;
          }
        });
        headersCode += '      }';
      } else {
        // Static headers
        headersCode = JSON.stringify(headers, null, 6);
      }
      
      // Handle request body
      const method = node.properties.method || 'GET';
      let bodyCode = 'undefined';
      
      if (method !== 'GET' && method !== 'HEAD') {
        const body = node.properties.body || {};
        
        if (typeof body === 'string') {
          if (body.includes('${')) {
            // Template string body
            bodyCode = '`' + body + '`';
          } else {
            // Regular string body
            try {
              // Check if it's a JSON string
              JSON.parse(body);
              bodyCode = body;
            } catch (e) {
              // Not JSON, use as is
              console.log(e);
              bodyCode = JSON.stringify(body);
            }
          }
        } else {
          // Object body
          bodyCode = JSON.stringify(body);
        }
      }
      
      code += `    const response_${safeNodeId} = await fetch(\n`;
      code += `      ${urlCode},\n`;
      code += `      {\n`;
      code += `        method: ${JSON.stringify(method)},\n`;
      code += `        headers: ${headersCode},\n`;
      
      if (method !== 'GET' && method !== 'HEAD') {
        if (bodyCode !== 'undefined') {
          const contentType = (headers && headers['Content-Type']) || (headers && headers['content-type']);
          
          if (contentType && contentType.includes('application/json')) {
            code += `        body: JSON.stringify(${bodyCode}),\n`;
          } else {
            code += `        body: ${bodyCode},\n`;
          }
        }
      }
      
      code += `      }\n`;
      code += `    );\n\n`;
      
      // Process response
      code += `    const processedResponse = await handleResponse(response_${safeNodeId});\n`;
      code += `    dataStore.${node.id} = processedResponse;\n`;
      
      return code;
    }
  
    /**
     * Generate code for a condition node
     * @param {Object} node - The condition node
     * @param {string} safeNodeId - Safe version of node ID for variable names
     * @returns {string} Generated code
     */
    _generateConditionNodeCode(node, safeNodeId) {
      let code = `    console.log('Evaluating condition: ${node.name}');\n`;
      
      const condition = node.properties.condition || 'false';
      
      code += `    const condition_${safeNodeId} = evaluateCondition(\n`;
      code += `      ${JSON.stringify(condition)},\n`;
      code += `      dataStore\n`;
      code += `    );\n`;
      code += `    dataStore.${node.id}_result = condition_${safeNodeId};\n`;
      
      return code;
    }
  
    /**
     * Generate code for a transform node
     * @param {Object} node - The transform node
     * @param {string} safeNodeId - Safe version of node ID for variable names
     * @returns {string} Generated code
     */
    _generateTransformNodeCode(node, safeNodeId) {
      let code = `    console.log('Executing transform: ${node.name}');\n`;
      
      const transform = node.properties.transform || '// No transform specified\nreturn dataStore;';
      
      code += `    const transform_${safeNodeId} = ((dataStore) => {\n`;
      code += `      try {\n`;
      
      // Split transform code into lines and add proper indentation
      const transformLines = transform.split('\n');
      transformLines.forEach(line => {
        code += `        ${line}\n`;
      });
      
      code += `      } catch (e) {\n`;
      code += `        console.error('Error in transform:', e);\n`;
      code += `        return null;\n`;
      code += `      }\n`;
      code += `    })(dataStore);\n`;
      code += `    dataStore.${node.id}_output = transform_${safeNodeId};\n`;
      
      return code;
    }
  
    /**
     * Generate flow control logic based on edges
     * @returns {string} Generated flow logic code
     */
    _generateFlowLogic() {
      let code = `  const flowLogic = {\n`;
      
      // Group edges by source node
      const edgesBySource = {};
      
      this.edges.forEach(edge => {
        if (!edgesBySource[edge.source]) {
          edgesBySource[edge.source] = {};
        }
        edgesBySource[edge.source][edge.sourcePort] = edge.target;
      });
      
      // Add grouped edges to the flow logic
      Object.entries(edgesBySource).forEach(([sourceId, ports]) => {
        code += `    '${sourceId}': {\n`;
        
        Object.entries(ports).forEach(([port, targetId]) => {
          code += `      '${port}': '${targetId}',\n`;
        });
        
        code += `    },\n`;
      });
      
      code += `  };\n\n`;
      
      // Add flow execution logic
      code += `  // Execute flow based on conditions\n`;
      code += `  let nextNode = Object.keys(flowLogic)[0]; // Start with first node\n`;
      code += `  const maxSteps = 100; // Prevent infinite loops\n`;
      code += `  let steps = 0;\n\n`;
      
      code += `  while (nextNode && steps < maxSteps) {\n`;
      code += `    steps++;\n`;
      code += `    const node = flowLogic[nextNode];\n`;
      code += `    if (!node) break;\n\n`;
      
      code += `    // Determine next step based on condition results\n`;
      code += `    if (dataStore[nextNode + '_result'] !== undefined) {\n`;
      code += `      // Handle condition nodes\n`;
      code += `      const result = dataStore[nextNode + '_result'] ? 'true' : 'false';\n`;
      code += `      nextNode = node[result];\n`;
      code += `    } else {\n`;
      code += `      // Handle other node types\n`;
      code += `      nextNode = node['response'] || node['output'] || null;\n`;
      code += `    }\n`;
      code += `  }\n\n`;
      
      return code;
    }
  
    /**
     * Sort nodes based on dependencies defined in edges
     * @returns {Array} Sorted nodes
     */
    _sortNodes() {
      const visited = new Set();
      const result = [];
      const nodeMap = {};
      
      // Create a map of nodes for quick access
      this.nodes.forEach(node => {
        nodeMap[node.id] = node;
      });
      
      // Create a graph of dependencies
      const graph = {};
      this.nodes.forEach(node => {
        graph[node.id] = [];
      });
      
      this.edges.forEach(edge => {
        if (graph[edge.source]) {
          graph[edge.source].push(edge.target);
        }
      });
      
      // Topological sort function
      const visit = (nodeId) => {
        if (visited.has(nodeId)) return;
        visited.add(nodeId);
        
        if (graph[nodeId]) {
          graph[nodeId].forEach(childId => {
            visit(childId);
          });
        }
        
        if (nodeMap[nodeId]) {
          result.unshift(nodeMap[nodeId]);
        }
      };
      
      // Visit all nodes
      this.nodes.forEach(node => {
        visit(node.id);
      });
      
      return result;
    }
  
    /**
     * Generate utility module file
     * @param {string} type - Module type ('esm' or 'commonjs')
     * @returns {string} Utility module code
     */
    generateUtilsModule(type = 'esm') {
      let code = `// WebPulse Flow Utilities\n\n`;
      
      // Add utility function implementations
      code += this._generateUtilityFunctions();
      
      // Export based on module type
      if (type === 'esm') {
        code += `export { handleResponse, evaluateCondition };\n`;
      } else {
        code += `module.exports = { handleResponse, evaluateCondition };\n`;
      }
      
      return code;
    }
  }
  
  // Example usage of the WebPulseFlowGenerator
  // 
  // const generator = new WebPulseFlowGenerator();
  // generator.importFlow({
  //   nodes: [
  //     {
  //       id: 'node-1',
  //       type: 'REQUEST',
  //       name: 'Get User Data',
  //       position: { x: 100, y: 100 },
  //       properties: {
  //         url: 'https://api.example.com/users/1',
  //         method: 'GET'
  //       }
  //     },
  //     {
  //       id: 'node-2',
  //       type: 'CONDITION',
  //       name: 'Check Status',
  //       position: { x: 300, y: 100 },
  //       properties: {
  //         condition: 'dataStore["node-1"].status === 200'
  //       }
  //     }
  //   ],
  //   edges: [
  //     {
  //       id: 'edge-1',
  //       source: 'node-1',
  //       sourcePort: 'response',
  //       target: 'node-2',
  //       targetPort: 'condition'
  //     }
  //   ]
  // });
  // 
  // const code = generator.generateCode();
  // console.log(code);
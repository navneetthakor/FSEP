// // WebPulseFlowGenerator.js - Clean implementation with proper request management
// export class WebPulseFlowGenerator {
//   constructor() {
//     this.nodes = [];
//     this.edges = [];
//   }

//   /**
//    * Import flow configuration from the canvas
//    * @param {Object} flowConfig - The flow configuration object
//    */
//   importFlow(flowConfig) {
//     this.nodes = flowConfig.nodes || [];
//     this.edges = flowConfig.edges || [];
//     return this;
//   }

//   /**
//    * Generate executable code for the flow
//    * @param {Object} options - Code generation options
//    * @returns {string} Generated code
//    */
//   generateCode(options = {}) {
//     const {
//       includeComments = true,
//       includeExampleUsage = true,
//       functionName = 'executeRequestFlow',
//       // errorHandling = 'basic',
//     } = options;
    
//     // Sort nodes to ensure dependencies are processed in correct order
//     const sortedNodes = this._sortNodes();
    
//     let code = '';
    
//     // Add header
//     if (includeComments) {
//       code += `// Generated by WebPulse Request Flow Generator\n`;
//       code += `// ${new Date().toISOString()}\n\n`;
//     }
    
//     // Start function definition
//     code += `async function ${functionName}(initialData = {}) {\n`;
//     code += `  // Initialize data store and request queue\n`;
//     code += `  const dataStore = { ...initialData };\n`;
//     code += `  const requestQueue = [];\n`;
//     code += `  const executedNodes = new Set();\n\n`;

//     // Add data reference utility function
//     code += `  // Utility function to reference data from previous steps\n`;
//     code += `  const getDataRef = (path) => {\n`;
//     code += `    return extractDataByPath(dataStore, path);\n`;
//     code += `  };\n\n`;
    
//     // Generate node registration code
//     code += `  // Register all nodes in the flow\n`;
//     sortedNodes.forEach(node => {
//       if (includeComments) {
//         code += `  // Register ${node.name} (${node.id})\n`;
//       }
      
//       code += this._generateNodeRegistration(node);
//     });
    
//     // Add main execution loop
//     code += `\n  // Execute the request flow\n`;
//     code += `  async function executeFlow() {\n`;
//     code += `    let nextNodeId = findStartNode();\n`;
//     code += `    const maxSteps = 100; // Prevent infinite loops\n`;
//     code += `    let steps = 0;\n\n`;
    
//     code += `    while (nextNodeId && steps < maxSteps) {\n`;
//     code += `      steps++;\n`;
//     code += `      const currentNode = requestQueue.find(n => n.id === nextNodeId);\n`;
//     code += `      if (!currentNode || executedNodes.has(nextNodeId)) break;\n\n`;
    
//     code += `      try {\n`;
//     code += `        console.log(\`Executing node: \${currentNode.name}\`);\n`;
//     code += `        await currentNode.execute();\n`;
//     code += `        executedNodes.add(nextNodeId);\n`;
    
//     code += `        // Determine next node based on the execution result\n`;
//     code += `        nextNodeId = determineNextNode(nextNodeId);\n`;
//     code += `      } catch (error) {\n`;
//     code += `        console.error(\`Error executing \${currentNode.name}:\`, error);\n`;
//     code += `        dataStore[\`\${nextNodeId}_error\`] = error;\n`;
//     code += `        if (errorHandling === 'continue') {\n`;
//     code += `          nextNodeId = determineNextNode(nextNodeId);\n`;
//     code += `        } else {\n`;
//     code += `          break;\n`;
//     code += `        }\n`;
//     code += `      }\n`;
//     code += `    }\n`;
//     code += `  }\n\n`;
    
//     // Add flow control logic
//     code += `  // Find the starting node in the flow\n`;
//     code += `  function findStartNode() {\n`;
//     code += `    // Find nodes that aren't targets of any edges\n`;
//     code += `    const targetNodeIds = new Set(${JSON.stringify(this.edges.map(e => e.target))});\n`;
//     code += `    const potentialStartNodes = requestQueue.filter(node => !targetNodeIds.has(node.id));\n`;
//     code += `    return potentialStartNodes.length > 0 ? potentialStartNodes[0].id : requestQueue[0]?.id;\n`;
//     code += `  }\n\n`;
    
//     code += `  // Determine the next node to execute based on the current node and its result\n`;
//     code += `  function determineNextNode(currentNodeId) {\n`;
//     code += `    const edges = ${JSON.stringify(this.edges)};\n`;
//     code += `    const relevantEdges = edges.filter(edge => edge.source === currentNodeId);\n\n`;
    
//     code += `    if (relevantEdges.length === 0) return null;\n\n`;
    
//     code += `    // For condition nodes, use the result to determine which path to take\n`;
//     code += `    const currentNode = requestQueue.find(n => n.id === currentNodeId);\n`;
//     code += `    if (currentNode && currentNode.type === 'CONDITION') {\n`;
//     code += `      const result = dataStore[\`\${currentNodeId}_result\`] ? 'true' : 'false';\n`;
//     code += `      const edge = relevantEdges.find(e => e.sourcePort === result);\n`;
//     code += `      return edge ? edge.target : null;\n`;
//     code += `    }\n\n`;
    
//     code += `    // For other nodes, take the first available edge\n`;
//     code += `    return relevantEdges[0]?.target || null;\n`;
//     code += `  }\n\n`;
    
//     // Call the flow execution
//     code += `  // Execute the flow\n`;
//     code += `  await executeFlow();\n\n`;
    
//     // Return data store
//     code += `  // Return the final data store\n`;
//     code += `  return dataStore;\n`;
//     code += `}\n\n`;

//     // Add data extraction utility function
//     code += `/**\n`;
//     code += ` * Extract data from an object using a dot or bracket notation path\n`;
//     code += ` * @param {Object} obj - The object to extract data from\n`;
//     code += ` * @param {string} path - Path using dot or bracket notation (e.g., "user.profile.name" or "responses[0].body.id")\n`;
//     code += ` * @returns {any} The extracted value or undefined if not found\n`;
//     code += ` */\n`;
//     code += `function extractDataByPath(obj, path) {\n`;
//     code += `  if (!obj || !path) return undefined;\n\n`;
//     code += `  // Handle special template syntax for data references\n`;
//     code += `  if (path.startsWith('\${') && path.endsWith('}')) {\n`;
//     code += `    path = path.slice(2, -1).trim();\n`;
//     code += `  }\n\n`;
//     code += `  // Split the path by dots or bracket notation\n`;
//     code += `  const keys = path.match(/\\[([^\\[\\]]*?)\\]|([^\\[\\]\\.]+)/g) || [];\n`;
//     code += `  let current = obj;\n\n`;
//     code += `  for (let key of keys) {\n`;
//     code += `    // Clean up the key by removing brackets and quotes\n`;
//     code += `    key = key.replace(/^\\[([^\\]]+)\\]$/, '$1')\n`;
//     code += `           .replace(/^\\["([^"]+)"\\]$/, '$1')\n`;
//     code += `           .replace(/^\\['([^']+)'\\]$/, '$1')\n`;
//     code += `           .replace(/^\\./g, '');\n\n`;
//     code += `    if (current === null || current === undefined) {\n`;
//     code += `      return undefined;\n`;
//     code += `    }\n\n`;
//     code += `    current = current[key];\n`;
//     code += `  }\n\n`;
//     code += `  return current;\n`;
//     code += `}\n\n`;

//     // Add handler for HTTP responses
//     code += `/**\n`;
//     code += ` * Process HTTP response and extract data\n`;
//     code += ` * @param {Response} response - Fetch API Response object\n`;
//     code += ` * @returns {Object} Processed response data\n`;
//     code += ` */\n`;
//     code += `async function handleResponse(response) {\n`;
//     code += `  const contentType = response.headers.get('content-type') || '';\n`;
//     code += `  let body;\n\n`;
//     code += `  if (contentType.includes('application/json')) {\n`;
//     code += `    body = await response.json();\n`;
//     code += `  } else if (contentType.includes('text/')) {\n`;
//     code += `    body = await response.text();\n`;
//     code += `  } else {\n`;
//     code += `    body = await response.arrayBuffer();\n`;
//     code += `  }\n\n`;
//     code += `  return {\n`;
//     code += `    status: response.status,\n`;
//     code += `    statusText: response.statusText,\n`;
//     code += `    headers: Object.fromEntries(response.headers.entries()),\n`;
//     code += `    body,\n`;
//     code += `    raw: response\n`;
//     code += `  };\n`;
//     code += `}\n\n`;
    
//     // Add example usage
//     if (includeExampleUsage) {
//       code += `// Example usage:\n`;
//       code += `// ${functionName}().then(result => console.log(result));\n`;
//     }
    
//     return code;
//   }

//   /**
//    * Generate code for node registration
//    * @param {Object} node - The node object
//    * @returns {string} Generated registration code
//    */
//   _generateNodeRegistration(node) {
//     let code = `  requestQueue.push({\n`;
//     code += `    id: '${node.id}',\n`;
//     code += `    name: '${node.name}',\n`;
//     code += `    type: '${node.type}',\n`;

//     switch (node.type) {
//       case 'REQUEST':
//         code += this._generateRequestNodeRegistration(node);
//         break;
        
//       case 'CONDITION':
//         code += this._generateConditionNodeRegistration(node);
//         break;
        
//       case 'TRANSFORM':
//         code += this._generateTransformNodeRegistration(node);
//         break;
        
//       default:
//         code += `    execute: async function() {\n`;
//         code += `      console.warn('Unknown node type: ${node.type}');\n`;
//         code += `    }\n`;
//     }
    
//     code += `  });\n`;
//     return code;
//   }

//   /**
//    * Generate registration code for a request node
//    * @param {Object} node - The request node
//    * @returns {string} Generated code
//    */
//   _generateRequestNodeRegistration(node) {
//     let code = `    properties: ${JSON.stringify(node.properties, null, 6)},\n`;
//     code += `    execute: async function() {\n`;
    
//     // Handle dynamic URL with support for data references
//     const url = node.properties.url || 'https://example.com';
//     const hasTemplateVars = url.includes('${');
//     let urlCode;
    
//     if (hasTemplateVars) {
//       urlCode = this._processTemplate(url);
//     } else {
//       urlCode = JSON.stringify(url);
//     }
    
//     // Handle headers with potential dynamic content
//     const headers = node.properties.headers || {};
//     let headersCode;
    
//     if (typeof headers === 'string') {
//       if (headers.includes('${')) {
//         headersCode = this._processTemplate(headers);
//       } else {
//         headersCode = headers;
//       }
//     } else if (Object.values(headers).some(val => typeof val === 'string' && val.includes('${'))) {
//       // Object with some dynamic values
//       headersCode = '{\n';
//       Object.entries(headers).forEach(([key, value]) => {
//         if (typeof value === 'string' && value.includes('${')) {
//           headersCode += `          "${key}": ${this._processTemplate(value)},\n`;
//         } else {
//           headersCode += `          "${key}": ${JSON.stringify(value)},\n`;
//         }
//       });
//       headersCode += '        }';
//     } else {
//       // Static headers
//       headersCode = JSON.stringify(headers, null, 6);
//     }
    
//     // Handle request body with data references
//     const method = node.properties.method || 'GET';
//     let bodyCode = 'undefined';
    
//     if (method !== 'GET' && method !== 'HEAD') {
//       const body = node.properties.body || {};
      
//       if (typeof body === 'string') {
//         if (body.includes('${')) {
//           bodyCode = this._processTemplate(body);
//         } else {
//           try {
//             JSON.parse(body);
//             bodyCode = body;
//           } catch (e) {
//             console.log(e);
//             bodyCode = JSON.stringify(body);
//           }
//         }
//       } else if (typeof body === 'object') {
//         const containsDataRefs = this._objectContainsDataRefs(body);
        
//         if (containsDataRefs) {
//           bodyCode = this._generateDynamicObjectCode(body);
//         } else {
//           bodyCode = JSON.stringify(body);
//         }
//       }
//     }
    
//     code += `      const url = ${urlCode};\n`;
//     code += `      const headers = ${headersCode};\n`;
    
//     if (method !== 'GET' && method !== 'HEAD' && bodyCode !== 'undefined') {
//       code += `      let body = ${bodyCode};\n`;
//       const contentType = (headers && (headers['Content-Type'] || headers['content-type']));
      
//       if (contentType && contentType.includes('application/json')) {
//         code += `      const requestBody = JSON.stringify(body);\n`;
//       } else {
//         code += `      const requestBody = body;\n`;
//       }
//     }
    
//     code += `\n      const response = await fetch(\n`;
//     code += `        url,\n`;
//     code += `        {\n`;
//     code += `          method: ${JSON.stringify(method)},\n`;
//     code += `          headers: headers,\n`;
    
//     if (method !== 'GET' && method !== 'HEAD' && bodyCode !== 'undefined') {
//       code += `          body: requestBody,\n`;
//     }
    
//     code += `        }\n`;
//     code += `      );\n\n`;
    
//     code += `      const processedResponse = await handleResponse(response);\n`;
//     code += `      dataStore['${node.id}'] = processedResponse;\n`;
//     code += `      return processedResponse;\n`;
//     code += `    }\n`;
    
//     return code;
//   }

//   /**
//    * Generate registration code for a condition node
//    * @param {Object} node - The condition node
//    * @returns {string} Generated code
//    */
//   _generateConditionNodeRegistration(node) {
//     let code = `    properties: ${JSON.stringify(node.properties, null, 6)},\n`;
//     code += `    execute: async function() {\n`;
    
//     const condition = node.properties.condition || 'false';
    
//     // Enhance condition to support data references
//     const enhancedCondition = condition.replace(/dataStore\[`([^`]+)`\]\.body\.([a-zA-Z0-9_]+)/g, 
//       'getDataRef(`$1.body.$2`)');
    
//     code += `      try {\n`;
//     code += `        // Create a safe evaluation function\n`;
//     code += `        const evalFunc = new Function('dataStore', 'getDataRef', \`return \${${JSON.stringify(enhancedCondition)}};\`);\n`;
//     code += `        const result = !!evalFunc(dataStore, getDataRef);\n`;
//     code += `        console.log(\`Condition evaluated to: \${result}\`);\n`;
//     code += `        dataStore['${node.id}_result'] = result;\n`;
//     code += `        return result;\n`;
//     code += `      } catch (error) {\n`;
//     code += `        console.error('Error evaluating condition:', error);\n`;
//     code += `        dataStore['${node.id}_error'] = error;\n`;
//     code += `        return false;\n`;
//     code += `      }\n`;
//     code += `    }\n`;
    
//     return code;
//   }

//   /**
//    * Generate registration code for a transform node
//    * @param {Object} node - The transform node
//    * @returns {string} Generated code
//    */
//   _generateTransformNodeRegistration(node) {
//     let code = `    properties: ${JSON.stringify(node.properties, null, 6)},\n`;
//     code += `    execute: async function() {\n`;
    
//     const transform = node.properties.transform || '// No transform specified\nreturn dataStore;';
    
//     code += `      try {\n`;
//     code += `        const transformFn = new Function('dataStore', 'getDataRef', \`\n`;
    
//     // Split transform code into lines and add proper indentation
//     const transformLines = transform.split('\n');
//     transformLines.forEach(line => {
//       code += `          ${line}\n`;
//     });
    
//     code += `        \`);\n`;
//     code += `        const result = transformFn(dataStore, getDataRef);\n`;
//     code += `        dataStore['${node.id}_output'] = result;\n`;
//     code += `        return result;\n`;
//     code += `      } catch (e) {\n`;
//     code += `        console.error('Error in transform:', e);\n`;
//     code += `        dataStore['${node.id}_error'] = e;\n`;
//     code += `        return null;\n`;
//     code += `      }\n`;
//     code += `    }\n`;
    
//     return code;
//   }

//   /**
//    * Process template strings with data references
//    * @param {string} template - Template string with potential data references
//    * @returns {string} Processed template with proper data reference code
//    */
//   _processTemplate(template) {
//     const processedTemplate = template.replace(/\${([^}]+)}/g, (match, path) => {
//       if (path.startsWith('dataStore.')) {
//         return '${' + path + '}';
//       }
//       return '${getDataRef(`' + path.replace(/`/g, '\\`') + '`)}';
//     });
    
//     return '`' + processedTemplate + '`';
//   }
  
//   /**
//    * Check if an object contains data references in any of its values
//    * @param {Object} obj - The object to check
//    * @returns {boolean} True if the object contains data references
//    */
//   _objectContainsDataRefs(obj) {
//     if (!obj || typeof obj !== 'object') return false;
    
//     return Object.values(obj).some(value => {
//       if (typeof value === 'string') {
//         return value.includes('${');
//       } else if (typeof value === 'object' && value !== null) {
//         return this._objectContainsDataRefs(value);
//       }
//       return false;
//     });
//   }
  
//   /**
//    * Generate code for dynamic object with data references
//    * @param {Object} obj - The object with potential data references
//    * @returns {string} Generated code for the dynamic object
//    */
//   _generateDynamicObjectCode(obj) {
//     if (!obj) return 'undefined';
    
//     let json = JSON.stringify(obj, null, 2);
    
//     const stringPattern = /"([^"]*\${[^"}]*[^"]*)""/g;
//     json = json.replace(stringPattern, (match, templateContent) => {
//       return '`' + templateContent.replace(/\\"/g, '"') + '`';
//     });
    
//     // Handle more complex nested templates
//     if (json.includes('${')) {
//       return '`' + json.replace(/`/g, '\\`').replace(/"/g, '\\"') + '`';
//     }
    
//     return json;
//   }

//   /**
//    * Sort nodes based on dependencies defined in edges
//    * @returns {Array} Sorted nodes
//    */
//   _sortNodes() {
//     const visited = new Set();
//     const result = [];
//     const nodeMap = {};
    
//     // Create a map of nodes for quick access
//     this.nodes.forEach(node => {
//       nodeMap[node.id] = node;
//     });
    
//     // Create a graph of dependencies
//     const graph = {};
//     this.nodes.forEach(node => {
//       graph[node.id] = [];
//     });
    
//     this.edges.forEach(edge => {
//       if (graph[edge.source]) {
//         graph[edge.source].push(edge.target);
//       }
//     });
    
//     // Topological sort function
//     const visit = (nodeId) => {
//       if (visited.has(nodeId)) return;
//       visited.add(nodeId);
      
//       if (graph[nodeId]) {
//         graph[nodeId].forEach(childId => {
//           visit(childId);
//         });
//       }
      
//       if (nodeMap[nodeId]) {
//         result.unshift(nodeMap[nodeId]);
//       }
//     };
    
//     // Visit all nodes
//     this.nodes.forEach(node => {
//       visit(node.id);
//     });
    
//     return result;
//   }

//   /**
//    * Generate a module of utility functions
//    * @param {string} moduleType - 'esm' or 'commonjs'
//    * @returns {string} Utility module code
//    */
//   generateUtilsModule(moduleType = 'esm') {
//     let code = `// WebPulse Flow Utilities\n\n`;
    
//     // Add utility functions implementations
//     code += `/**\n`;
//     code += ` * Extract data from an object using a dot or bracket notation path\n`;
//     code += ` * @param {Object} obj - The object to extract data from\n`;
//     code += ` * @param {string} path - Path using dot or bracket notation\n`;
//     code += ` * @returns {any} The extracted value or undefined if not found\n`;
//     code += ` */\n`;
//     code += `function extractDataByPath(obj, path) {\n`;
//     code += `  if (!obj || !path) return undefined;\n\n`;
//     code += `  // Handle special template syntax for data references\n`;
//     code += `  if (path.startsWith('\${') && path.endsWith('}')) {\n`;
//     code += `    path = path.slice(2, -1).trim();\n`;
//     code += `  }\n\n`;
//     code += `  // Split the path by dots or bracket notation\n`;
//     code += `  const keys = path.match(/\\[([^\\[\\]]*?)\\]|([^\\[\\]\\.]+)/g) || [];\n`;
//     code += `  let current = obj;\n\n`;
//     code += `  for (let key of keys) {\n`;
//     code += `    // Clean up the key\n`;
//     code += `    key = key.replace(/^\\[([^\\]]+)\\]$/, '$1')\n`;
//     code += `           .replace(/^\\["([^"]+)"\\]$/, '$1')\n`;
//     code += `           .replace(/^\\['([^']+)'\\]$/, '$1')\n`;
//     code += `           .replace(/^\\./g, '');\n\n`;
//     code += `    if (current === null || current === undefined) {\n`;
//     code += `      return undefined;\n`;
//     code += `    }\n\n`;
//     code += `    current = current[key];\n`;
//     code += `  }\n\n`;
//     code += `  return current;\n`;
//     code += `}\n\n`;
    
//     code += `/**\n`;
//     code += ` * Process HTTP response and extract data\n`;
//     code += ` * @param {Response} response - Fetch API Response object\n`;
//     code += ` * @returns {Object} Processed response data\n`;
//     code += ` */\n`;
//     code += `async function handleResponse(response) {\n`;
//     code += `  const contentType = response.headers.get('content-type') || '';\n`;
//     code += `  let body;\n\n`;
//     code += `  if (contentType.includes('application/json')) {\n`;
//     code += `    body = await response.json();\n`;
//     code += `  } else if (contentType.includes('text/')) {\n`;
//     code += `    body = await response.text();\n`;
//     code += `  } else {\n`;
//     code += `    body = await response.arrayBuffer();\n`;
//     code += `  }\n\n`;
//     code += `  return {\n`;
//     code += `    status: response.status,\n`;
//     code += `    statusText: response.statusText,\n`;
//     code += `    headers: Object.fromEntries(response.headers.entries()),\n`;
//     code += `    body,\n`;
//     code += `    raw: response\n`;
//     code += `  };\n`;
//     code += `}\n\n`;
    
//     // Export based on module type
//     if (moduleType === 'esm') {
//       code += `export { extractDataByPath, handleResponse };\n`;
//     } else {
//       code += `module.exports = { extractDataByPath, handleResponse };\n`;
//     }
    
//     return code;
//   }
// }